%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                             %
%   Center for Astronomy Signal Processing and Electronics Research           %
%   http://casper.berkeley.edu                                                %      
%   Copyright (C) 2011 Suraj Gowda,   Hong Chen                               %
%   Copyright (C) 2007 Terry Filiba, Aaron Parsons                            %
%   Copyright (C) 2009 Andrew Martens                                         %
%                                                                             %
%   This program is free software; you can redistribute it and/or modify      %
%   it under the terms of the GNU General Public License as published by      %
%   the Free Software Foundation; either version 2 of the License, or         %
%   (at your option) any later version.                                       %
%                                                                             %
%   This program is distributed in the hope that it will be useful,           %
%   but WITHOUT ANY WARRANTY; without even the implied warranty of            %
%   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the             %
%   GNU General Public License for more details.                              %
%                                                                             %
%   You should have received a copy of the GNU General Public License along   %
%   with this program; if not, write to the Free Software Foundation, Inc.,   %
%   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.               %
%                                                                             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function fft_stage_n_init_xblock(blk, varargin)
%                 'depend',{'fft_butterfly_init_xblock'}
%            
%                             {'butterfly_arith_dsp48e_init_xblock',...
%                             'fft_twiddle_init_xblock','simd_add_dsp48e_init_xblock',...
%                             'convert_of_init_xblock', ...
%                             'c_to_ri_init_xblock','cmacc_dsp48e_init_xblock',...
%                             'simd_add_dsp48e_init_xblock','coeff_gen_init_xblock'}
                                            
                                            
defaults = { ...
    'FFTSize', 3, ...
    'FFTStage', 1, ...
    'input_bit_width', 18, ...
    'coeff_bit_width', 18, ...
    'coeffs_bram', 'off', ...
    'delays_bram', 'off', ...
    'quantization', 'Round  (unbiased: +/- Inf)', ...
    'overflow', 'Saturate', ...
    'add_latency', 2, ...
    'mult_latency', 3, ...
    'bram_latency', 2, ...
    'conv_latency', 1, ...
    'mux_latency', 1, ...    
    'arch', 'Virtex5', ...
    'opt_target', 'logic', ...
    'use_hdl', 'off', ...
    'use_embedded', 'on', ...
    'hardcode_shifts', 'off', ...
    'downshift', 'off', ...
    'dsp48_adders', 'on', ...
    'bit_growth', 0, ...
    'negate_latency', 3, ...
    'negate_dsp48e', 1, ...
};

% Retrieve values from mask fields.
FFTSize = get_var('FFTSize', 'defaults', defaults, varargin{:});
FFTStage = get_var('FFTStage', 'defaults', defaults, varargin{:});
input_bit_width = get_var('input_bit_width', 'defaults', defaults, varargin{:});
coeff_bit_width = get_var('coeff_bit_width', 'defaults', defaults, varargin{:});
coeffs_bram = get_var('coeffs_bram', 'defaults', defaults, varargin{:});
delays_bram = get_var('delays_bram', 'defaults', defaults, varargin{:});
quantization = get_var('quantization', 'defaults', defaults, varargin{:});
overflow = get_var('overflow', 'defaults', defaults, varargin{:});
add_latency = get_var('add_latency', 'defaults', defaults, varargin{:});
mult_latency = get_var('mult_latency', 'defaults', defaults, varargin{:});
bram_latency = get_var('bram_latency', 'defaults', defaults, varargin{:});
conv_latency = get_var('conv_latency', 'defaults', defaults, varargin{:});
arch = get_var('arch', 'defaults', defaults, varargin{:});
opt_target = get_var('opt_target', 'defaults', defaults, varargin{:});
use_hdl = get_var('use_hdl', 'defaults', defaults, varargin{:});
use_embedded = get_var('use_embedded', 'defaults', defaults, varargin{:});
hardcode_shifts = get_var('hardcode_shifts', 'defaults', defaults, varargin{:});
downshift = get_var('downshift', 'defaults', defaults, varargin{:});
dsp48_adders = get_var('dsp48_adders', 'defaults', defaults, varargin{:});
bit_growth = get_var('bit_growth', 'defaults', defaults, varargin{:});
use_dsp48_mults = get_var('use_dsp48_mults', 'defaults', defaults, varargin{:});
negate_latency = get_var('negate_latency', 'defaults', defaults, varargin{:});
negate_dsp48e = get_var('negate_dsp48e', 'defaults', defaults, varargin{:});
mux_latency = get_var('mux_latency', 'defaults', defaults, varargin{:});


%% inports
in1 = xInport('in1');
in2 = xInport('in2');
of_in = xInport('of_in');
sync = xInport('sync');
shift = xInport('shift');
% biplex_sel = xInport('biplex_sel');

%% outports
out1 = xOutport('out1');
out2 = xOutport('out2');
of = xOutport('of');
sync_out = xOutport('sync_out');
shift_out = xOutport('shift_out');
shift_out.assign(shift); % propagate to next stage

%% diagram
%flag error and over-ride if trying to use BRAMs but delay is less than BRAM latency
if (2^(FFTSize-FFTStage) <= bram_latency)
    if strcmp(delays_bram,'on')
        disp('fft_stage_n_init: using BRAMs for delays but BRAM latency larger than delay! Forcing use of distributed RAM.');
    end
    delays_bram = 'off';
end

if FFTSize < FFTStage
    errorlog('Invalid setting:  FFTSize < FFTStage');
end
 

if(FFTStage == 1 ),
    Coeffs = 0;
else
    Coeffs = 0:2^(FFTStage-1)-1;
end
StepPeriod = FFTSize-FFTStage;

% Compute the complex, bit-reversed values of the twiddle factors
br_indices = bit_rev(Coeffs, FFTSize-1);
br_indices = -2*pi*1j*br_indices/2^FFTSize;
ActualCoeffs = exp(br_indices);

%% Signals
w = xSignal('w');

% block: untitled2/fft_stage_n_init_xblock/Logical1
butterfly_direct_out3 = xSignal;
Logical1 = xBlock(struct('source', 'Logical', 'name', 'Logical1'), ...
                         struct('logical_function', 'OR', ...
                                'latency', 1, ...
                                'n_bits', 8, ...
                                'bin_pt', 2), ...
                         {butterfly_direct_out3, of_in}, ...
                         {of});

% block: untitled2/fft_stage_n_init_xblock/Mux

delay_f_out1 = xSignal;
Mux_out1 = xSignal;
Counter_out1 = xSignal;
Slice1_out1 = xSignal;
Mux = xBlock(struct('source', 'Mux', 'name', 'Mux'), ...
	struct('latency', mux_latency, 'Precision', 'Full'), ...
	{Slice1_out1, delay_f_out1, in1}, {Mux_out1});

% block: untitled2/fft_stage_n_init_xblock/Mux1
Mux1_out1 = xSignal;
Mux1 = xBlock(struct('source', 'Mux', 'name', 'Mux1'), ...
	struct('latency', mux_latency, 'Precision', 'Full'), ...
	{Slice1_out1, in1, delay_f_out1}, {Mux1_out1});

% block: untitled2/fft_stage_n_init_xblock/Slice
Slice_out1 = xSignal;
Slice = xBlock(struct('source', 'Slice', 'name', 'Slice'), ...
                      struct('boolean_output', 'on', ...
                             'mode', 'Lower Bit Location + Width', ...
                             'bit1', -(FFTStage - 1), ...
                             'bit0', FFTStage - 1), ...
                      {shift}, ...
                      {Slice_out1});

% block: untitled2/fft_stage_n_init_xblock/Counter

Counter = xBlock(struct('source', 'Counter', 'name', 'Counter'), ...
                       struct('n_bits', FFTSize-FFTStage+1, ...
                              'rst', 'on', ...
                              'explicit_period', 'off', ...
                              'use_rpm', 'off'), ...
                       {sync}, ...
                       {Counter_out1});
% block: untitled2/fft_stage_n_init_xblock/Slice1
Slice1 = xBlock(struct('source', 'Slice', 'name', 'Slice1'), ...
                      [], ...
                      {Counter_out1}, ...
                      {Slice1_out1});


if FFTStage == 1
    twiddle_type = 'twiddle_pass_through';
    coeff_latency = 0;
elseif FFTStage == 2
    twiddle_type = 'twiddle_stage_2';
    coeff_latency = 0;
else
    twiddle_type = 'twiddle_general_4mult';
    coeff_latency = bram_latency;
end

delay_b_out1 = xSignal;
sync_delay_out1 = xSignal;
sync_coeff_delay = xSignal('sync_coeff_delay');
a_coeff_delay = xSignal('a_coeff_delay');
b_coeff_delay = xSignal('b_coeff_delay');
butterfly_direct_sub = xBlock(struct('source', str2func('fft_butterfly_init_xblock'), 'name', 'butterfly_direct'), ...
                                 { [blk,'/butterfly_direct'], ...
                                  'biplex', 'on', ...
								  'Coeffs', Coeffs, ...
								  'StepPeriod', StepPeriod, ...
								  'FFTSize', FFTSize, ...
								  'input_bit_width', input_bit_width, ...
								  'coeff_bit_width', coeff_bit_width, ...
								  'add_latency', add_latency, ...
								  'mult_latency', mult_latency, ...
								  'bram_latency', bram_latency, ...
								  'negate_latency', negate_latency, ...
								  'negate_dsp48e', negate_dsp48e, ...
								  'coeffs_bram', coeffs_bram, ...
								  'conv_latency', conv_latency, ...
								  'quantization', quantization, ...
								  'overflow', overflow, ...
								  'arch', arch, ...
								  'opt_target', opt_target, ...
								  'use_hdl', use_hdl, ...
								  'use_embedded', use_embedded, ...
								  'hardcode_shifts', hardcode_shifts, ...
								  'downshift', downshift, ...
								  'dsp48_adders', dsp48_adders, ...
								  'use_dsp48_mults', use_dsp48_mults, ...
                                  'bit_growth', bit_growth, ...
                                  'twiddle_type', twiddle_type}, ...
                                 {a_coeff_delay, b_coeff_delay, w, sync_coeff_delay, Slice_out1}, ...
                                 {out1, out2, butterfly_direct_out3, sync_out});


                             
% block: untitled2/fft_stage_n_init_xblock/sync_delay
sync_delay_sub = xBlock(struct('source', str2func('sync_delay_init_xblock'), 'name', 'sync_delay'), ...
                           {[blk,'/sync_delay'], 2^(FFTSize - FFTStage)+mux_latency}, ...
                           {sync}, ...
                           {sync_delay_out1});

% Delay a, b, and sync to match coefficient latency (e.g. bram delay)
xBlock(struct('source', 'Delay', 'name', 'sync_coeff_delay'), ...
    {'latency', coeff_latency}, {sync_delay_out1}, {sync_coeff_delay});
xBlock(struct('source', 'Delay', 'name', 'a_coeff_delay'), ...
    {'latency', coeff_latency}, {delay_b_out1}, {a_coeff_delay});
xBlock(struct('source', 'Delay', 'name', 'b_coeff_delay'), ...
    {'latency', coeff_latency}, {Mux_out1}, {b_coeff_delay});


% Coefficient generator
xBlock(struct('source', str2func('coeff_gen_init_xblock'), 'name', 'coeff_gen'), ...
    {[], ActualCoeffs, coeff_bit_width, StepPeriod, bram_latency, coeffs_bram}, ...
    {sync_delay_out1}, {w});
                           
% Implement delays using fabric or BRAM
% TODO: use the "combined" delay block
if strcmp(delays_bram, 'on')
	% instantiate delay_b
	delay_b_sub = xBlock(struct('source', str2func('delay_bram_init_xblock'), 'name', 'delay_b'), ...
		{[blk,'/delay_b'], 'latency', 2^(FFTSize-FFTStage), ...
			'bram_latency', bram_latency, 'count_using_dsp48', 'off'},...
		{Mux1_out1}, ...
		{delay_b_out1});
	
	% instantiate delay_f
	delay_f_sub = xBlock(struct('source', str2func('delay_bram_init_xblock'), 'name', 'delay_f'), ...
		{[blk,'/delay_b'], 'latency', 2^(FFTSize-FFTStage), ...
			'bram_latency', bram_latency, 'count_using_dsp48', 'off'},...
		{in2}, ...
		{delay_f_out1});
else 	
	% instantiate delay_b
	delay_b_sub = xBlock(struct('source', 'Delay', 'name', 'delay_b'), ...
							{'latency', 2^(FFTSize-FFTStage)}, ...
							{Mux1_out1}, ...
							{delay_b_out1});
	
	% instantiate delay_f
	delay_f_sub = xBlock(struct('source', 'Delay', 'name', 'delay_f'), ...
							{'latency', 2^(FFTSize-FFTStage)}, ...
							{in2}, ...
							{delay_f_out1});
end                           


% if ~isempty(blk) && ~strcmp(blk(1),'/')
%     clean_blocks(blk);
%     del = 'slices';
%     coeff = 'slices';
%     if strcmp(delays_bram,'on') del = 'BRAM'; end
%     if strcmp(coeffs_bram,'on') coeff = 'BRAM'; end
% 
%     fmtstr = sprintf('[%d/%d]\ndelays in %s\ncoeffs in %s\nBit growth = %d\n', FFTStage, FFTSize, del, coeff,bit_growth);
%     set_param(blk, 'AttributesFormatString', fmtstr);
% end
end

